import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.naive_bayes import GaussianNB
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, roc_auc_score
from sklearn.preprocessing import StandardScaler, OrdinalEncoder
from sklearn.impute import SimpleImputer
from datetime import datetime, timedelta

# Load the asset data and maintenance tasks datasets
asset_data = pd.read_excel('../AssetForecast/ML/AssetDataRisk.xlsx')
maintenance_data = pd.read_excel('../AssetForecast/ML/maintenancetasks.xlsx')

# Merge the asset data with maintenance tasks data on 'barcode'
merged_data = pd.merge(asset_data, maintenance_data, on='barcode', how='left')

# Convert 'createdDate' and 'completedAt' columns to datetime objects
merged_data['createdDate'] = pd.to_datetime(merged_data['createdDate'])
merged_data['completedAt'] = pd.to_datetime(merged_data['completedAt'])

# Calculate the time until the next maintenance task
merged_data['time_until_next_maintenance'] = merged_data.groupby('barcode')['createdDate'].diff().dt.total_seconds().fillna(0)

# Define the target variable: maintenance needed not within a certain time threshold
threshold = 60 * 24 * 3600  # Maintenance needed if next task more than 60 days
merged_data['maintenance_needed'] = (merged_data['time_until_next_maintenance'] > threshold).astype(int)

# Drop one-hot encoded columns
merged_data = merged_data.drop(columns=['assetType', 'assetCondition', 'assetRepairCategory', 'environmentalRating', 'impactRating'])

# Encode categorical variables using OrdinalEncoder
encoder = OrdinalEncoder()
merged_data[['assetType', 'assetCondition', 'assetRepairCategory', 'environmentalRating', 'impactRating']] = encoder.fit_transform(merged_data[['assetType', 'assetCondition', 'assetRepairCategory', 'environmentalRating', 'impactRating']])

# Select features and target variable
X = merged_data[['assetLifeExpectancy', 'assetAge', 'riskScore']]
y = merged_data['maintenance_needed']

# Preprocessing: Handling Missing Values
imputer = SimpleImputer(strategy='mean')
X_imputed = imputer.fit_transform(X)

# Preprocessing: Feature Scaling
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X_imputed)

# Split data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=42)

# Initialize and train the model
model = GaussianNB()
model.fit(X_train, y_train)

# Define function to predict maintenance for specific time intervals
def predict_maintenance(model, X, time_interval):
    # Get current date
    current_date = datetime.now()
    
    # Calculate future date based on time interval
    future_date = current_date + timedelta(days=time_interval)
    
    # Prepare input data for prediction
    input_data = pd.DataFrame({
        'assetLifeExpectancy': [X['assetLifeExpectancy'].mean()],  # Assuming mean values for features
        'assetAge': [X['assetAge'].mean()],  # Assuming mean values for features
        'riskScore': [X['riskScore'].mean()],  # Assuming mean values for features
    })
    
    # Preprocess input data
    input_data_imputed = imputer.transform(input_data)
    input_data_scaled = scaler.transform(input_data_imputed)
    
    # Make prediction
    predicted_maintenance = model.predict(input_data_scaled)
    
    return predicted_maintenance[0]

# Predict maintenance for different time intervals
time_intervals = {'Next 7 Days': 7, '2 Weeks': 14, '1 Month': 30, '6 Months': 6*30, '1 Year': 365}
for interval_name, interval_days in time_intervals.items():
    maintenance_required = predict_maintenance(model, X, interval_days)
    print(f"Maintenance required in {interval_name}: {'Yes' if maintenance_required == 1 else 'No'}")
